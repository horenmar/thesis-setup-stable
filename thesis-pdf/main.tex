\input ctustyle
\input pdfuni
\input glosdata
\input opmac-bib

\worktype [B/EN]
\faculty {F3}
\department {Katedra řídící techniky}
\title {The Use of Symbolic Execution for Testing of Real-Time
        Safety-Related Software}
\titleCZ {Využití symbolické exekuce pro testování real-time,
          bezpečnostně kritického softwaru}
\author {Martin Hořeňovský}
\authorinfo {horenmar@fel.cvut.cz}
\supervisor {Ing. Michal Sojka, Ph.D.}
\studyinfo {Otevřená informatika - Informatika a počítačové vědy}
\date {Květen 2015}
\abstractEN {Safety critical software is hard!.}
\keywordsEN {Symbolic execution, KLEE, automatic testing,
             security-critical systems, automotive domain}
\abstractCZ {Safety critical software is hard!
             \rfc{Translate the english abstract}}
\keywordsCZ {Symbolická exekuce, KLEE, automatické testování,
             bezpečnostně kritický software, automobilová doména
             \rfc{Standartní překlad??}}
\thanks{I would like to thank my supervisor Ing. Michal Sojka, Ph.D.
        for having patience with my lazy ass. \rfc{Selfcensorship?}
        I also want to thank Petr Olšák for creating almost unified template
        for CTU.}
\declaration {
I hereby declare that I made this on my own and I declared
all used sources according to ``Metodický pokyn o dodržování
etických principů při přípravě vysokoškolských závěřečných prací''

\vskip 4cm
\chyph
Prohlašuji, že jsem předloženou práci vypracoval samostatně
a že jsem uvedl veškeré použité informační zdroje v souladu
s Metodickým pokynem o dodržování etických principů při přípravě
vysokoškolských závěrečných prací.

\signature
}


%Some draft iteration related "defines"
\draft %-- Remove this to finalize pdf.
\savetoner
 
\makefront
\chap Introduction

Words...


\sec Motivation

\sec What is the goal

\sec Structure

\sec Following text



\chap Background and related software

\sec Safety-critical software and security

\sec Symbolic execution

Symbolic execution is a testing technique where program is run through an
interpreter, which allows for inputs to be symbolic as opposed to concrete.
This allows the interpreter to go through all possible paths in a program,
without having to generate all possible inputs. This also allows to connect
specific branches in the program with constraints upon inputs that lead there.

Unlike with fuzzing, time required for symbolic execution of any given program
doesn't increase exponentially with size of input, but rather increases with
amount of branches (possible paths) through the program. Also, if symbolic
execution encounters an infinite loop, it will never terminate. Various
solutions to increase path coverage exist, including parallelizing independent
paths\cite[c9-paper], usage of heuristics to guide search
\cite[klee-paper, symdrive-paper, c9-paper] and usage of annotations.\cite[symdrive-paper]

\secc Existing tools

\sec KLEE

KLEE is a symbolic execution tool primarily geared towards performing
high-coverage tests on programs originally created by Cadar et al. \cite[klee-paper]

It is built on the LLVM compiler infrastructure, as it uses its front-end to
convert C code in to LLVM IR representation, which it then works on.

While its original purpose was to test general purpose programs, we \rfc{I?}
decided to test its fitness for testing real-time safety critical software,
because such software's number of paths through code is relatively small.

By itself, KLEE can find and show paths that lead to any of

\begitems
* Assertion violation
* Access outside of allocated memory
* Null pointer dereference
\enditems

during my work on this thesis, KLEE was also extended to handle integer oveflow
checking, but needs support from the compiler.

\secc KLEE integer overflow checking

When I started to work on using KLEE for testing real-time safety-critical
software, it was unable to detect integer overflow. In a case of parallel
development, both Dariz Luca and I independently added this capability to KLEE,
and Dariz's patches have been since merged into mainline KLEE.\cite[overflow-merge]

KLEE is currently relying on Clang's support for Undefined Behavior Sanitizer
(also known as ``ubsan''), which in turn is based on Regehr et al's work on
integer overflow checking.\cite[ioc-paper] KLEE implements overflow checking
by performing arithmetic operations as-if done on wider types and then
checking upper half of the result. If it isn't empty, overflow must have
occured.

KLEE can check for overflow of both signed and unsigned integral types, but the
checks have to be turned on and/or off during tested program's compilation.
This is caused by KLEE piggybacking on Clang's intrinsics.

\sec Real-Time safety-critical applications

\secc eMotor

eMotor is proprietary control software for Infineon Tricore TC1798 motor.

\secc MaCAN

MaCAN library\urlnote{https://github.com/CTU-IIG/macan} implements
MaCAN protocol for Linux, Infineon Tricore TC1798 and STM32 architectures.
MaCAN protocol builds upon CAN protocol to provide additional security
through authenticating control messages received from the network.\cite[MaCAN-paper]



\chap Toolchain and case study preparation

\sec KLEE stuff

\rfc{make a better headline}

\sec eMotor modifications

\sec MaCAN modifications

\chap Evaluation

\sec Results - problems, bugs, solutions?

\rfc {Again, better headline} 

\sec Complexity, limitations, execution time

\sec KLEE fitness for purpose

\chap Conclusion



\bibchap
\usebib/c (simple) mybase
%\usebib/<sorttype> (<style>) <bibfile>
%sorttype c -- citation order in text
%sorttype s -- by key in style file


%Supposedly "Zadání práce" if in czech.
\app Specification


\rfc{Include assignment in czech as well.}

\app Glossary\par
\makeglos

\nextoddpage

\bye
