\input ctustyle
\input pdfuni
\input glosdata
\input opmac-bib

%\shortcitations %Would be normally defined by the template, but I decided
% to comment it out preventively.
\sortcitations  %Sort citation order for citation lists
%That means turn [5, 3, 4, 7] into [3, 4, 5, 7] or [3-5, 7]

\parskip=\medskipamount \parindent=0pt

\worktype [B/EN]
\faculty {F3}
\department {Department of Cybernetics}
\title {The Use of Symbolic Execution for Testing of Real-Time
        Safety-Related Software}
\titleCZ {Využití symbolické exekuce pro testování real-time,
          bezpečnostně kritického softwaru}
\author {Martin Hořeňovský}
\authorinfo {horenmar@fel.cvut.cz}
\supervisor {Ing. Michal Sojka, Ph.D.}
\studyinfo {Open Informatics --- Computer and Information Science}
\date {May 2015}
\abstractEN {This thesis investigates fitness of symbolic execution tool KLEE
for verification of real-time safety-critical systems. Real-time
safety-critical systems are those systems, whose malfunction might result in
death of people and/or environmental damage.

In this thesis I modify two pieces of real-time safety-critical
software to test them with KLEE and evaluate how complex was the modification
and whether using KLEE is viable going forward.}

\abstractCZ {Tato práce zkoumá vhodnost nástroje symbolické exekuce KLEE pro
verifikaci real-time bezpečnostně kritických systémů. Real-time bezpečnostně
kritické systémy jsou ty, u kterých selhání může vést ke ztrátě lidských životů
anebo ke škodám na životním prostředí.

V této práci modifikuji dva real-time bezpečnostně kritické systémy, abych je
mohl otestovat s KLEE a posoudit, jak komplikovaná jejich modifikace byla a zda
má smysl začít používat KLEE k verifikaci real-time bezpečnostně kritických
systémů.}
             
\keywordsEN {Symbolic execution, KLEE, automatic testing,
             security-critical systems, automotive domain}
\keywordsCZ {Symbolická exekuce, KLEE, automatické testování,
             bezpečnostně kritický software, automobilový průmysl}
\thanks{I would like to thank my supervisor Michal Sojka for his guidance
        and advices.}
\declaration {
I hereby declare that I made this on my own and I declared
all used sources according to ``Metodický pokyn o dodržování
etických principů při přípravě vysokoškolských závěřečných prací''

\vskip 4cm
\chyph
Prohlašuji, že jsem předloženou práci vypracoval samostatně
a že jsem uvedl veškeré použité informační zdroje v souladu
s Metodickým pokynem o dodržování etických principů při přípravě
vysokoškolských závěrečných prací.

\signature
}


%Some draft iteration related "defines"
\draft %-- Remove this to finalize pdf.
%\savetoner
 
\makefront




\chap Introduction

Security used to be thought of as completely orthogonal to safety-critical
software, because such software was expected to be completely isolated from
outside world, and if networked, the network was thought to be completely
isolated from the outside world. These assumptions are becoming more and more
outdated, with recent example being the ability to locate and unlock Tesla
Model S electric car by hacking a trivially brute-forceable
code~\cite[tesla-security].

While no tool can prevent security vulnerabilities caused by naive
authentication scheme, automatic testing can find security {\em implementation}
bugs which could potentially allow an attack to bypass security measures that
are in place. Thus there is a need to test new methods of verification of
real-time safety-critical software.

In this thesis I attempt to determine whether a general purpose symbolic
execution tool, KLEE, can help find bugs in existing real-time safety-critical
software. While its original purpose was to test general purpose programs, we
decided to test its fitness for testing real-time safety critical software,
because such software's number of paths through code is relatively small, which
mitigates the main downside of symbolic execution, its exponential complexity
in number of branches in the executed program.

The rest of this work is organized as follows. Second chapter, Background and
Related Technologies introduces basic information about undefined behaviour,
safety-critical software, symbolic execution and already existing tools using
it, the tool I am testing in this thesis and the two pieces of safety-critical
software we will use to evaluate KLEE's fitness for purpose. Third chapter,
Toolchain and case study preparation, covers work performed in the course of
writing my thesis. It covers work done on KLEE, eMotor software and the MaCAN
library.

Fourth chapter, Evaluation, covers results, such as number of bugs found using
KLEE, their severity, time it took to find them and whether KLEE will be useful
tool for testing safety-critical real-time software going forward. The final
chapter, Conclusion, recapitulates our findings and recommendations.

There are also 4 appendices. Appendix A is the specification for this thesis,
Appendix B is glossary of terms used in this thesis, Appendix C lists contents
of the enclosed DVD and Appendix D contains detailed data and results from the
testing.




\chap Background and related technologies

Standard C~\cite[iso-C99] places no constraints upon the result of program invoking undefined
behaviour (UB), and this is often interpreted by compilers as allowance to
generate arbitrary output for such program. It also defines many causes of
undefined behaviour, such as\fnote{Taken from ISO C99 Appendix 
J.2~\cite[iso-C99]}
\begitems
* Dereferencing uninitialized pointer
* Dereferencing a NULL pointer
* Dereferencing pointer to no longer valid object (i.e. freed object)
* Creating pointers outside of allocated memory
* Converting pointers to objects of incompatible types (e.g. converting "float*"
  to "int*")
* Signed integer overflow (unsigned overflow is well defined)
* Shifting values by more than its size (ie "int64_t i = 1 << 70")
* Evaluating arithmetic expression that would be mathematically undefined
  (e.g. division by zero)
\enditems
Modern compilers use undefined behaviour to perform optimizations and code in
Figure~\ref[ub-sample1] will be transformed into code in
Figure~\ref[ub-transform1] by such compiler. The reasoning is that since
a program cannot contain undefined behaviour, and the function dereferences
"ptr", it cannot be null or the function would invoke undefined behaviour. This
allows the compiler to remove the conditional branch and error checking, which
is seen as worthwhile optimization.

\midinsert \clabel[ub-sample1]{Example of undefined behaviour invoking code}
\begtt
int foo(int* ptr){
    int temp = *ptr;
    if (!ptr){
        return ERR;
    }
    ...
}
\endtt
\caption/f Example of undefined behaviour invoking code.
\endinsert

\midinsert \clabel[ub-transform1]{Code after compiler transformation}
\begtt
int foo(int* ptr){
    int temp = *ptr;
    ...
}
\endtt
\caption/f Code after compiler transformation.
\endinsert

The willingness of compilers to exploit undefined behaviour in code has
already been documented as causing security bugs in real
world~\cite[linux-kernel-vuln], but defined behaviour can lead to bugs as well.
A common example is unsigned overflow, which is well defined, but often is not
accounted for and breaks program's logic. 

While static analysis can find some of these potential defects (e.g.
dereferencing uninitialized pointers and incompatible pointer conversions),
it is not sound and gives both false positives and false negatives. Static
analysis is also unable to find integer overflows, as these are inherently
dynamic and the only viable way to detect them is with tools performing runtime
checking.

\sec Safety-critical software and security

Safety-critical systems are those systems whose malfunction and/or failure
might result in death (or grievous injury) of people, severe damage to and/or
loss of equipment and environmental damage. These systems are increasingly
often implemented in software, as opposed to hardware, or as mechanic,
pneumatic, hydraulic, ..., systems and new methods of software defect
prevention are needed.

There are various ways to decrease the number and frequency of software
malfunctions, such as specific development methodologies (e.g. MISRA C%
\urlnote{http://www.misra.org.uk/MISRAHome/WhatisMISRA/tabid/66/Default.aspx},
and JSF-AV C++ coding standards\urlnote{http://www.stroustrup.com/JSF-AV-rules.pdf})
which aim to provide safer subset of the language, thus decreasing possible
space for defects and set requirements for testing rigour. Similarly, since
compilation is another potential source of software defects, there are formally
provable compilers~\cite[compcert-paper].

In general, safety-critical systems often have hard real-time requirements and
to be fully defined for all possible inputs. This means that software contained
within must always respond under a fixed time-limit and have to fully define
its failure modes, even if the response is just turning off motor and engaging
emergency breaks.

\sec Symbolic execution

The term symbolic execution has been coined in year 1976 by James C. King in
article Symbolic execution and program 
testing~\cite[symbolic-execution-article]. Since then symbolic execution has
been implemented by various tools for various languages, from x86 
assembly~\cite[s2e-paper], LLVM's intermediate representation (IR)
(from C/C++)~\cite[klee-paper, c9-paper]
to higher level languages such as the .NET framework~\cite[pex-repair-paper].

The contents of rest of this section are heavily based on the KLEE 
paper~\cite[klee-paper] and the S2E paper~\cite[s2e-paper].
Symbolic execution is a testing technique where program is run through an
interpreter, which allows for inputs to be symbolic, as opposed to concrete.
While run under interpreter, symbolic data (either input or variables) are
not actual data, but rather a set of boolean formulae that have been placed
upon them by conditions along the currently executing path. This allows the
interpreter to go through all possible paths in a program, without having to
generate all possible inputs. This is achieved by keeping track of all
conditions leading to any given path and using a SAT solver to A)~determine
whether any given path can be taken and  B)~generate a sample solution
(concretization of symbolic data) that will lead to any given path. As an
example, consider the function in Figure~\ref[sample-symbolic-function].

\midinsert \clabel[sample-symbolic-function]{Example function}
\begtt
int is_odd(int n){
    if (n % 2) {
        return 1;
    } else {
        return 0;
    }
}
\endtt
\caption/f Example function for symbolic execution.
\endinsert

It has $2^{32}$ possible concrete inputs, but as can be easily seen,
has only two paths through. Symbolic testing allows us to find both paths
without having to explore all $2^{32}$ inputs. If we mark the input as symbolic
and use KLEE to test this function, it outputs both paths and gives concretized
values that give full coverage as can be seen in
Figure~\ref[klee-sample-listing].

\midinsert \clabel[klee-sample-listing]{Abbreviated KLEE's output for the example}
\begtt
KLEE: done: total instructions = 29
KLEE: done: completed paths = 2
KLEE: done: generated tests = 2
...
args       : ['is_odd.o']
num objects: 1
object    0: name: 'n'
object    0: size: 4
object    0: data: 0
...
args       : ['is_odd.o']
num objects: 1
object    0: name: 'n'
object    0: size: 4
object    0: data: 1
\endtt
\caption/f Abbreviated KLEE's output for the example.
\endinsert

Unlike with fuzzing, time required for symbolic execution of any given program
doesn't increase exponentially with size of input, but rather increases with
amount of branches (possible paths) through the program. This allows use of
symbolic testing on much larger programs than just using random inputs. 

On the other hand, certain kinds of conditional branching are more or less
unsolvable. Consider checking cryptographic hash of a symbolic value against
predetermined result. For symbolic tool to be able to give us a concrete value
or a set of constraints is asking it to reverse a cryptographic hash, which is
generally regarded impossible without brute-force testing the input space, and
in special cases might be impossible completely. Other problematic constructs
are unbounded loops (i.e. those waiting for a hardware response) and infinite
loops, which prevent symbolic execution from terminating.

Various solutions to increase path coverage exist, including parallelizing
independent paths~\cite[c9-paper], usage of heuristics to guide search
\cite[klee-paper, symdrive-paper, c9-paper, kite-paper], usage of 
annotations~\cite[symdrive-paper] and selective symbolic
execution~\cite[s2e-paper].

\secc Existing tools

There exist various tools for performing symbolic execution, many of which are
based on KLEE~\cite[symdrive-paper, c9-paper, s2e-paper, kite-paper].

Cloud9\urlnote{http://cloud9.epfl.ch/}
is a symbolic executor that can scale over clusters of machines, and
a cloud service for testing software~\cite[c9-paper]. It's innovation is dynamic
partitioning of search space while having a shared-nothing architecture. It is
also capable of executing C++ code.

S2E\urlnote{http://s2e.epfl.ch/}
is a platform for analysing large scale programs {\em in vivo}. It accomplishes
this by using {\em selective symbolic execution} a technique that automatically
minimalises amount of symbolically executed code within a binary. Together with
relaxed execution consistency, this allows S2E to analyse code as run in its
real environment~\cite[s2e-paper].

SymDrive\urlnote{http://research.cs.wisc.edu/sonar/projects/symdrive/}
is a tool for testing Linux and FreeBSD drivers without
hardware~\cite[symdrive-paper]. It uses static-analysis to automatically find
driver entry points and loops, together with source to source transformation,
which often allows it to test a driver without requiring any modifications by
its author and if it cannot create modified driver automatically (that is, it
cannot perform necessary transformations for testing), it alerts the developer
as to what changes are required~\cite[symdrive-paper].

Kite\urlnote{http://www.cs.ubc.ca/labs/isd/Projects/Kite/}
is a KLEE based tool that prunes its search space whenever a path is proven
to be infeasible. It is based on recent improvements of Conflict-Driven Clause
Learning (CDCL) Boolean Satisfiability Problem (SAT) solvers and uses markedly
different exploration strategy from other tools, in that it looks for paths
which allow it to ``learn'' the most, that is, prune the search space the
most~\cite[kite-paper].

\sec KLEE

KLEE is a symbolic execution tool primarily geared towards performing
high-coverage tests on programs, originally created by Cadar et
al.~\cite[klee-paper]. It is built on the LLVM compiler infrastructure, using
its Clang front-end to convert C code to LLVM intermediate representation (IR),
which it then works on.

Officially KLEE still has LLVM-2.9 and LLVM-GCC as its dependencies, which are
currently almost 4 years outdated. Since then there was significant amount of
work done to allow KLEE to work with newer version of the LLVM toolchain and
Clang instead of LLVM-GCC, but the only officially supported toolchain is
LLVM-2.9 and LLVM-GCC. The officially supported version of Simple Theorem
Prover (STP) SAT solver is {\em extremely} outdated as well. Later chapter
covers what did I have to do to be able to use it for testing.

KLEE can find and show paths that lead to any of
\begitems
* Assertion violation
* Access outside of allocated memory (including null pointer dereference and
  double free)
* Division by zero
* Integer overshift (shifting an integer by more than its size)
* Call to "abort()"
\enditems
and recently was also extended to handle integer overflow checking, as detailed
in later section.



\secc Principle of operation

Text in this subsection is based on the KLEE paper~\cite[klee-paper].

KLEE takes a file of LLVM IR as its input and works directly on the LLVM IR.
LLVM IR is a low-level programming language resembling strongly typed assembly
for a very abstracted machine. It uses infinite set of registers, supports
floating point, variable width integers, exception handling, atomicity and
threads, but also explicit calling conventions. There are two (three) standard
forms of LLVM IR, human-readable assembly, serialized bitcode (and C++
objects). KLEE is capable of interpreting most of LLVM IR, but it does not
support symbolic floating point, threads, "longjmp", embedded assembly
code and some intrinsics. All memory allocations also have to have concrete
size.

At the core of KLEE testing is an interpreter loop, selecting a currently open
state. KLEE's state consists of the current values of registers, stack and heap
objects as represented by expression trees built from LLVM IR operations. The
interpreter then executes current LLVM IR instruction according to the current
state. If the instruction does not branch, its execution is straightforward,
but if the executed instruction is a conditional branch instruction, KLEE uses
a SAT solver to determine whether the condition is provably true or false given
current state and constraints created along the path taken to reach it, in
which case KLEE takes the appropriate path. If the conditional branch cannot be
proved to be either, KLEE creates two new states with added constraints from
the branch. These two states are then added to priority queue of all open
states.

Branches can also be created implicitly, by potentially dangerous operations.
Every division, pointer dereference and similar instructions create an implicit
branch that checks for possibility of error. For example, division instruction
creates a branch checking whether the divisor can be equal to zero, and if it
can, it terminates the state and generates test case leading to to it.

This interpreter loop and state expansion continue while there are open states
in its priority queue or while a user defined timeout has not expired.

\secc KLEE integer overflow checking

When I started working with KLEE, it was unable to detect integer overflow. We
decided to add support for checking integer overflow, but at the same time
Dariz Luca had implemented it as well and since his work has been
mainlined~\cite[overflow-merge], I will talk about his implementation.

This capability relies on Clang's support for Undefined Behavior Sanitizer
(also known as ``ubsan'')\urlnote{http://blog.regehr.org/archives/905},
which in turn is based on work by Regehr et al. on integer overflow
checking~\cite[ioc-paper]. KLEE implements overflow checking by performing
arithmetic operations as-if done on double sized types and then checking upper
half of the result. If it is not empty, the operation must have overflown.

KLEE can check for overflow of both signed and unsigned integral types, but the
checks have to be turned on and/or off during tested program's compilation.
This is caused by KLEE's reliance on Clang's intrinsics.

\secc Example of KLEE usage

This subsection explains basic usage of KLEE. We will go through running KLEE
on two toy single file programs, "sum.c" and "memcpyassert.c", whose listings
are in Figure~\ref[sum-listing] and Figure~\ref[memcpyassert-listing]
respectively. We will use Clang-3.3 as our LLVM IR compiler.

\midinsert \clabel[sum-listing]{{\tt sum.c} listing}
\begtt
#include "klee/klee.h"

int read_int(){
    int res;
    klee_make_symbolic(&res, sizeof(res), "summand");
    return res;
}

int main(){
    int total = 0;
    for (int i = 0; i < 5; ++i){
        total += read_int();
    }
    return 0;
}
\endtt
\caption/f {\tt sum.c} listing
\endinsert

\midinsert \clabel[memcpyassert-listing]{{\tt memcpyassert.c} listing}
\begtt
#include "klee/klee.h"
#include <string.h>
#include <assert.h>

int read_int(){
    int res;
    klee_make_symbolic(&res, sizeof(res), "some int");
    return res;
}

int main(){
        int a, b;
        a = read_int();

        memcpy(&b, &a, sizeof(b));

        assert(b != 0);

        return 0;
}
\endtt
\caption/f {\tt memcpyassert.c} listing
\endinsert

Because KLEE runs on LLVM bitcode files, the first step is to run Clang on
the source file as seen in Figure~\ref[compilation-cmd]. The result of this
step is a ".o" file containing LLVM bitcode, which can be now run by KLEE as
seen in Figure~\ref[how-to-run-klee].

\midinsert \clabel[compilation-cmd]{Compilation command line}
\begtt
clang -emit-llvm -c -g -fsanitize=integer <name>.c
\endtt
\caption/f Compilation command line
\endinsert

\midinsert \clabel[how-to-run-klee]{How to run KLEE}
\begtt
klee <name>.o
\endtt
\caption/f How to run KLEE
\endinsert

The output of running KLEE on "sum.o" can be seen in 
Figure~\ref[klee-sum-results] and in Figure~\ref[klee-memcpy-results] for
"memcpyassert.o". As they show, both of these toy programs contain possible
bugs. For "sum.c" it is a possible signed\fnote{Yes, signed. KLEE's overflow
reporting currently contains a bug and reports every overflow as unsigned.}
integer overflow, which is undefined behaviour and "memcpyassert.o" contains
possible assertion violation.

\midinsert \clabel[klee-sum-results]{KLEE results for {\tt sum.c}}
\begtt
KLEE: output directory is "/.../thesis-setup-stable/examples/klee-out-0"
KLEE: ERROR: /.../thesis-setup-stable/examples/sum.c:12: overflow on
unsigned addition
KLEE: NOTE: now ignoring this error at this location

KLEE: done: total instructions = 218
KLEE: done: completed paths = 5
KLEE: done: generated tests = 2
\endtt
\caption/f KLEE results for {\tt sum.c}
\endinsert

\midinsert \clabel[klee-memcpy-results]{KLEE results for {\tt memcpyassert.c}}
\begtt
KLEE: output directory is "/.../thesis-setup-stable/examples/klee-out-1"
KLEE: ERROR: /.../thesis-setup-stable/examples/memcpyassert.c:12:
ASSERTION FAIL: b != 0
KLEE: NOTE: now ignoring this error at this location

KLEE: done: total instructions = 62
KLEE: done: completed paths = 2
KLEE: done: generated tests = 2
\endtt
\caption/f KLEE results for {\tt memcpyassert.c}
\endinsert

For every run KLEE creates a new folder with several files, as can be seen in
Figure~\ref[klee-files]. In addition to files created for the execution itself,
"assembly.ll", "info", "messages.txt", "run.stats", "run.istats" and
"warnings.txt", KLEE has created sample inputs for every distinct path through
the sample programs and for every error found ("test<n>.ktest") and if the path
generated an error, two more files: "test<n>.pc" with condition guarding the
error and "test<n>.<err>" with details about the error (what kind, where in the
source code, call stack).  

\midinsert \clabel[klee-files]{list of files in KLEE's results directory}
\begtt
assembly.ll   run.istats        test000001.overflow.err  warnings.txt
info          run.stats         test000001.pc
messages.txt  test000001.ktest  test000002.ktest
\endtt
\caption/f list of files in KLEE's results directory
\endinsert

The "test<n>.ktest" files are in a binary format, so KLEE comes with an utility
to read them, "ktest-tool". If used it writes out human readable list of
symbolic variables and their concrete values that would lead program execution
through to its corresponding path. For an example, see Figure~\ref[ktest-tool].

\midinsert \clabel[ktest-tool]{Sample listing of ktest-tool output}
\begtt
/.../klee-last$ ktest-tool --write-ints test000001.ktest
ktest file : 'test000001.ktest'
args       : ['sum.o']
num objects: 2
object    0: name: 'summand'
object    0: size: 4
object    0: data: 1073741824
object    1: name: 'summand'
object    1: size: 4
object    1: data: 1073741824
\endtt
\caption/f Sample listing of ktest-tool output
\endinsert

KLEE also writes out runtime statistics, including branch coverage, LLVM IR
instruction coverage, total time spent running, and so on.
Figure~\ref[klee-example-stats] shows an example of usage and output.

\midinsert \clabel[klee-example-stats]{Sample listing of klee-stats output}
\begtt
/.../examples$ klee-stats klee-last
------------------------------------------------------------------------
|  Path   |  Instrs|  Time(s)|  ICov(%)|  BCov(%)|  ICount|  TSolver(%)|
------------------------------------------------------------------------
|klee-last|     218|     0.23|    29.59|    12.50|     169|       97.19|
------------------------------------------------------------------------
\endtt
\caption/f Sample listing of klee-stats output.
\endinsert

\sec Real-Time safety-critical applications

This section covers the two pieces of real-time safety-critical software we
decided to use to evaluate KLEE's fitness for testing real-time safety-critical
software. We chose eMotor because at the time we had a joint project with
Infineon and MaCAN library because the Industrial Informatics Group created it.

\secc eMotor

The eMotor driver is Infineon Technologies' proprietary electric motor control software module for
AUTomotive Open System ARchitecture (AUTOSAR\urlnote{http://www.autosar.org/}), standardized software
architecture for automotive domain.
It has an interrupt driven design (the entire control algorithm is
executed inside the interrupt handler) and is designed to run on 32-bit Tricore
TC1798 microcontroller. It requires proprietary IDE, compiler, assembler and
linker to be compiled.

\secc MaCAN

Controller Area Network (CAN) bus is standard communication bus for vehicles,
designed by Bosch~\cite[bosch-can]. The CAN protocol is message based and there
are two different message formats, standard frame format and extended frame format.
Because it was usually assumed that attackers do not have access to the
network inside vehicle, CAN was designed for deterministic real-time
communication, reliability and robustness and no consideration was given to
security. However modern vehicles often have at least one remotely accessible
interfaces and thus there is now a need to have message security as part of the
communication protocol.

The MaCAN protocol contains both a key exchange protocol and a means of 
message authentication, giving a measure of message security and has an
advantage in that it builds upon the CAN bus and is backwards compatible with
already existing deployments of CAN. Because of these backward compatibility
constraints, such as only 8 byte payload in a single CAN frame, MaCAN protocol
cannot use more than 32 bits for its Message Authentication codes and thus the
cryptographic security is weaker than would be recommended in other domains.
However, this is mitigated by other factors, such as short lived keys and the
relative slowness of CAN network limiting rate at which an attacker can make
guesses.~\cite[MaCAN-paper]

The MaCAN library\urlnote{https://github.com/CTU-IIG/macan} implements the
MaCAN protocol for Linux, Infineon Tricore TC1798 and STM32
architectures~\cite[MaCAN-thesis]. It was designed to be cross-platform by only
having single, platform-independent dependency, cryptographic library Nettle%
\urlnote{http://www.lysator.liu.se/~nisse/nettle/} and by separating platform
dependent code from bulk of the library.

My investigation was done on a snapshot of the MaCAN library taken at commit
1dac9fed8b9777d32e0c28b2b826b8ac36f146a5%
\urlnote{https://github.com/horenmar/macan/commit/1dac9fed8b9777d32e0c28b2b826b8ac36f146a5}
with added modification to allow testing with KLEE. I will talk about these
in the following chapter.




\chap Toolchain and case study preparation

This chapter covers changes done to KLEE, eMotor and MaCAN to allow testing
these two libraries using KLEE. It will also cover problems I ran into along
the way, touching upon some ``personal'' experience gained during this thesis.

Virtually all my work is also available online, in a GitHub repository%
\urlnote{https://github.com/horenmar/thesis-setup-stable}.

\sec KLEE preparation

Because KLEE's overflow checking relies on Clang's UndefinedBehaviorSanitizer,
I had to find a way of compiling and linking together binary from multiple
source files using Clang. Because the bitcode linking facilities in LLVM have
been deleted between the 2.9 (officially supported by KLEE) version and 3.3
(first version with ubsan support) version, I used the Whole program LLVM%
\urlnote{https://github.com/travitch/whole-program-llvm} (WLLVM) utility
created by Tristan Ravitch.

WLLVM works by using a compiler capable of emitting both normal object
files and the LLVM bitcode, generating both and saving bitcode into normal
object file. During linking the bitcode sections are also linked together and
the final bitcode program can then be extracted from resulting
binary~\cite[wllvm-working] and run in KLEE.

Furthermore, to enable integer overflow checking I had to change how WLLVM
calls Clang, which means that whether WLLVM compiles code with overflow checking
enabled or disabled is hardcoded into the utility itself. The patch itself is
from the KLEE mailing list~\cite[wllvm-patch].

\sec eMotor modifications

Because the eMotor's access to HW registers is weakly abstracted, modifying
eMotor to support symbolic execution has proven to be hard. This, combined with
time issues and the fact the project for which we worked on eMotor has ended,
led us to give up on testing eMotor.

\sec MaCAN modifications

As mentioned before, MaCAN's architecture has decoupled architecture specific
code from the general library code. This allowed me to initially make no
changes to the library part of MaCAN code, shimming hardware dependencies to
return symbolic values when run under KLEE.

However, the MaCAN library inner working is deeply reliant on cryptography and
validating cryptography using symbolic execution is intractable. Because of
this I ended up having to bypass parts of the code, compromising completeness
of testing coverage to be able to analyse the rest of MaCAN library codebase.

More specifically, in addition to adding KLEE as a platform to the MaCAN project
and adding the necessary platform-specific scaffolding, I only had to perform
small modifications to the original library source in the form of conditional
compilation and create a dummy MaCAN node application, to create a valid
execution entry point for KLEE.

\midinsert \clabel[diffstat]{Statistics of my work on MaCAN library}
\begtt
 build/klee/Makefile.omk        |    1 +
 build/klee/clear_early.sh      |   12 +
 build/klee/config.target       |   11 +
 build/klee/macan               |    1 +
 build/klee/nettle              |    1 +
 build/klee/node/Makefile.omk   |    4 +
 build/klee/node/node.c         |  138 ++++
 build/klee/run_klee.sh         |    5 +
 macan/include/Makefile.omk     |    3 +
 macan/include/klee.h           |    7 +
 macan/src/Makefile.omk         |    1 +
 macan/src/cryptlib.c           |    9 +
 macan/src/klee/klee_cryptlib.c |   39 ++
 macan/src/klee/klee_macan.c    |   41 ++
 macan/src/klee/macan_ev.c      |  102 +++
 macan/src/klee/macan_ev.h      |   82 +++
 macan/src/macan.c              |    6 +-
\endtt
\caption/f Statistics of my work on MaCAN library.
\endinsert

Figure~\ref[diffstat] shows overall statistics of changes during my work
in the MaCAN repository, minus boilerplate files of MaCAN's build system.
Figure~\ref[macan-ev-loop] shows dummy event loop used to invoke the MaCAN
library, Figure~\ref[macan-klee-hw] shows my implementation of MaCAN's platform
hardware specific functionality and Figure~\ref[macan-klee-crypto] shows my
implementation of MaCAN's platform specific cryptographic functionality.

\midinsert \clabel[macan-rx-cb]{{\tt Listing of CAN receive callback}}
\begtt
void
can_rx_cb(macan_ev_loop *loop, macan_ev_can *w, int revents){
    (void)loop; (void)revents; /* suppress warnings */
    struct macan_ctx *ctx = w->data;
    struct can_frame cf;

    while (macan_read(ctx, &cf))
        macan_process_frame(ctx, &cf);
}
\endtt
\caption/f {\tt Listing of CAN receive callback.}
\endinsert

As can be seen in Figure~\ref[macan-ev-loop], the testing harness consists of
a loop called three times, where it each time goes through all registered
timers (which for the test program means calling the ``housekeeping'' timer,
that is responsible for renewing expired keys) and then calls the MaCAN library
entry point for received messages, "can_rx_cb". As seen in
Figure~\ref[macan-rx-cb], this callback loops while there are current messages
and as Figure~\ref[macan-klee-hw] shows, 10 messages can be read in a row. This
means that every path through the program found by KLEE has read 30 messages.

Figure~\ref[macan-crypto-patch] shows patch that was needed in the general
MaCAN implementation of "cryptlib.c" (I also removed static linkage from
function serving as entry point for CAN frames in "macan.c").

All my modifications are publicly available as a fork of the original project%
\urlnote{https://github.com/horenmar/macan/tree/klee} as well as on the DVD
accompanying this thesis (see Appendix C for more detail).

\midinsert \clabel[macan-ev-loop]{Listing of KLEE's event loop for testing}
\begtt
bool
macan_ev_run(macan_ev_loop *loop){
       for (int i = 0; i < 3; ++i){
               uint64_t now = read_time();

               for (macan_ev_timer *t = loop->timers; t; t = t->next) {
                       if (now >= t->expire_us) {
                               t->cb(loop, t, MACAN_EV_TIMER);
                               t->expire_us = now + t->repeat_us;
                       }
               }

               can_rx_cb(NULL /*ignored*/, loop->cans, 0 /*ignored*/);

       }
       return true;
}
\endtt
\caption/f Listing of KLEE's event loop for testing.
\endinsert

\midinsert \clabel[macan-klee-crypto]{Overview of MaCAN's KLEE target implementation}
\begtt
void macan_aes_cmac(const struct macan_key *key, size_t length,
                    uint8_t *dst, uint8_t *src){
    (void)key, (void)length, (void)dst, (void)src;
    memset(dst, 0, 16);
}

void macan_aes_encrypt(const struct macan_key *key, size_t len,
                       uint8_t *dst, const uint8_t *src){
    (void)key, (void)src;
    klee_make_symbolic(dst, len, "aes encryption");
}

void macan_aes_decrypt(const struct macan_key *key, size_t len,
                       uint8_t *dst, const uint8_t *src){
    (void)key, (void)src;
    klee_make_symbolic(dst, len, "aes decryption");
}

\endtt
\caption/f Overview of MaCAN's KLEE target implementation. {\tt cryptlib.c}
\endinsert

\midinsert \clabel[macan-crypto-patch]{Necessary patch against {\tt cryptlib.c}}
\begtt
 void macan_unwrap_key(const struct macan_key *key, size_t srclen,
                       uint8_t *dst, uint8_t *src) {
+#ifdef WITH_KLEE
+       klee_make_symbolic(dst+16, 7, "aes unwrap modification");
+#else
        macan_aes_unwrap(key, srclen, dst, src, src);
+#endif
 }
\endtt
\caption/f Necessary patch against {\tt cryptlib.c}.
\endinsert

\midinsert \clabel[macan-klee-hw]{Overview of MaCAN's KLEE target implementation}
\begtt
uint64_t read_time(void){
       uint64_t time;
       klee_make_symbolic(&time, sizeof(time), "time");
       return time;
}

bool gen_rand_data(void* dest, size_t len){
       memset(dest, 0, len);
       return true;
}

bool macan_read(struct macan_ctx* ctx, struct can_frame* cf){
       (void)ctx;
       klee_make_symbolic(cf, sizeof(struct can_frame),
                         "incoming can frame");
       static int counter = 0;
       counter++;
       counter %= 10;
       return counter != 0;
}

void macan_target_init(struct macan_ctx* ctx){
       (void)ctx;
}

//Not currently part of testing.
bool macan_send(struct macan_ctx* ctx, const struct can_frame* cf){
       (void)ctx, (void)cf;
       return true;
}
\endtt
\caption/f Overview of MaCAN's KLEE target implementation. {\tt macan.c}
\endinsert

Figure~\ref[1signal] shows messages sent in the MaCAN network when it first
establishes itself. Because CAN messages received by the node are symbolic
in our testing, we are only interested in messages the node receives
(they are marked with ">>" in the figure). There are 16 messages that we need
to receive to simulate a node startup, and all messages afterwards are a payload.

As I already mentioned, my test harness forces the MaCAN library to receive a
total of 30 messages, meaning that our node receives enough messages to perform
initial initialization and then 14 messages extra. This means that our testing
harness could exercise all paths through the MaCAN library, except those that
make use of cryptographic primitives or those that rely on specific node
configuration (as the node configuration for our test harness was concrete.)

\midinsert \clabel[1signal]{List of initialization messages on MaCAN network}
\begtt
  0.007 40029DCA42EE41EA crypt TS->KS (1->0): challenge fwd_id=S
  0.007 4003653631FB679F crypt TS->KS (1->0): challenge fwd_id=R
  0.007 00000000         time 0
  0.007 4001FB8D4CB204DD crypt S->KS (2->0): challenge fwd_id=TS
  0.007 4003CBFC5E431EEB crypt S->KS (2->0): challenge fwd_id=R
  0.007 4001ED728E635600 crypt R->KS (3->0): challenge fwd_id=TS
  0.007 4002A90562E93EA7 crypt R->KS (3->0): challenge fwd_id=S
  0.007 81068C7BB634DCB8 crypt KS->TS (0->1): sess_key seq=0 len=6
  0.007 8116527F367675FE crypt KS->TS (0->1): sess_key seq=1 len=6
  0.007 8126F2E868371D44 crypt KS->TS (0->1): sess_key seq=2 len=6
  0.007 81365DA64E2999FE crypt KS->TS (0->1): sess_key seq=3 len=6
  0.007 814680FEB6BA8926 crypt KS->TS (0->1): sess_key seq=4 len=6
  0.007 815236F1B6BA8926 crypt KS->TS (0->1): sess_key seq=5 len=2
  0.007 0201             crypt KS->S (0->2): req challenge fwd_id=TS
  0.008 810633B3D3CDFC50 crypt KS->TS (0->1): sess_key seq=0 len=6
  0.008 8116C2AD9E7A9B20 crypt KS->TS (0->1): sess_key seq=1 len=6
  0.008 81262D798AF157C3 crypt KS->TS (0->1): sess_key seq=2 len=6
  0.008 8136EAD1B8033C06 crypt KS->TS (0->1): sess_key seq=3 len=6
  0.008 8146E89D3BC0985A crypt KS->TS (0->1): sess_key seq=4 len=6
  0.008 815229A33BC0985A crypt KS->TS (0->1): sess_key seq=5 len=2
>>0.008 0301             crypt KS->R (0->3): req challenge fwd_id=TS
  0.009 4100F14494135731 crypt S->TS (2->1): challenge fwd_id=KS
>>0.010 0302             crypt KS->R (0->3): req challenge fwd_id=S
  0.010 0000000077F739C5 authenticated time 0
  0.010 81040000BD50C3F9 crypt S->TS (2->1): ack group=[2]
>>0.010 83040000252D298E crypt S->R (2->3): ack group=[2]
>>0.011 83064C12C76D9612 crypt KS->R (0->3): sess_key seq=0 len=6
>>0.011 831695FAED34F1B6 crypt KS->R (0->3): sess_key seq=1 len=6
>>0.011 83268DEFEE67C20E crypt KS->R (0->3): sess_key seq=2 len=6
>>0.011 833628066B8A5CB9 crypt KS->R (0->3): sess_key seq=3 len=6
>>0.011 83463C529952A7A9 crypt KS->R (0->3): sess_key seq=4 len=6
>>0.011 8352ABB29952A7A9 crypt KS->R (0->3): sess_key seq=5 len=2
  0.011 41000CC006A7A332 crypt R->TS (3->1): challenge fwd_id=KS
>>0.011 8306F18851EF18A6 crypt KS->R (0->3): sess_key seq=0 len=6
>>0.011 8316853B6B3D173A crypt KS->R (0->3): sess_key seq=1 len=6
>>0.011 8326B5867DB711E5 crypt KS->R (0->3): sess_key seq=2 len=6
>>0.011 833640EE35D796E6 crypt KS->R (0->3): sess_key seq=3 len=6
>>0.011 834652C89235C20A crypt KS->R (0->3): sess_key seq=4 len=6
>>0.011 83520BEC9235C20A crypt KS->R (0->3): sess_key seq=5 len=2
  0.011 0000000054D0F079 authenticated time 0
  0.011 81080000EFC1FEAA crypt R->TS (3->1): ack group=[3]
  0.011 820800008987F55D crypt R->S (3->2): ack group=[3]
>>0.011 830C00005F99C3D4 crypt S->R (2->3): ack group=[2 3]
  0.011 C20000FE2B6430   crypt R->S (3->2): auth req + MAC signal=#0 presc=0
\endtt
\caption/f List of initialization messages on MaCAN network.
\endinsert




\chap Evaluation

This chapter presents results I obtained by running KLEE on the MaCAN library
to evaluate its viability as testing tool of real-time, safety-critical
software. Because of the already mentioned difficulties with modifying eMotor
to run under KLEE, results from testing eMotor are not included.

\sec Findings

When I ran KLEE on the modified MaCAN library, KLEE has reported some potential
errors. After fixing Assertion and access violation caused by my
misconfiguration of the test client, I ran KLEE again in two configurations.
One using the default heuristics as its search strategy and one using DFS as
its search strategy. Statistics for resulting bugs found are in 
Table~\ref[klee-results].

\midinsert \clabel[klee-results]{Number of bugs found}
\ctable{lr}{
\hfil Type of bug & Count \crl \tskip4pt
    Assertion violation & 0 \cr
    Access outside of allocated memory & 0 \cr
    Division by zero & 0 \cr
    Integer overshift & 0 \cr
    Calls to abort & 0 \cr
    Integer overfow & 8 \cr
}
\caption/t Number of bugs found.
\endinsert

As can be seen, the only reports were for integer overflows. The numbers for
these are further broken down in Table~\ref[overflow-results]. All of them were
found in arithmetic expressions containing time. To determine whether the
potential overflow in any given report is dangerous or not, I used simple
rules: any and all signed overflows invoke UB and as such are always considered
dangerous. For unsigned overflows, I used personal inspection and assistance
from my supervisor, Michal Sojka\fnote{Michal Sojka is one of the MaCAN library
authors and current maintainer.}.

\midinsert \clabel[overflow-results]{Number of overflows found}
\ctable{lr}{
\hfil Type of overflow & Count \crl \tskip4pt
    benign & 5 \cr
    causing bugs & 2 \cr
    causing undefined behaviour & 1 \cr
}
\caption/t Number of overflows found.
\endinsert

The one case of undefined-behaviour-causing overflow was in function checking
authenticity of received message. The programmer wanted to test whether the
message was authentic, assuming it was sent either slightly before ``now''
(that is, current MaCAN time), now, or after now and wrote the code in
Figure~\ref[ub-code], where the  expression "(int)time + i" performed signed
arithmetic that could easily overflow.

\midinsert \clabel[ub-code]{Listing of the UB causing bug}
\begtt
uint64_t time;
int i;
...
time = macan_get_time(ctx);

for (i = -1; i <= 1; i++) {
    *ftime = htole32((int)time + i);
    macan_aes_cmac(skey, len, cmac, plain);

    if (memcmp(cmac4, cmac, 4) == 0) {
        return 1;
    }
}
\endtt
\caption/f Listing of the UB causing bug.
\endinsert

\midinsert \clabel[ub-fix]{Listing of the fix for UB causing bug}
\begtt
int delta_t;
uint32_t time = (uint32_t)macan_get_time(ctx);
for (delta_t = -1; delta_t <= 1; delta_t++) {
    *ftime = htole32(time + (uint32_t)delta_t);
}
\endtt
\caption/f Listing of the fix for UB causing bug in mainline MaCAN.
\endinsert

After I found this bug, it was fixed in
mainline MaCAN library, by changing the code to the one in
Figure~\ref[ub-fix]~\cite[MaCAN-UB-fix]. The new version can still overflow
(in fact it has to overflow to work properly), but the new overflow is well
defined from the language point of view and is intended (and thus benign).

One of the two non-benign overflows was found in function that receives time
from the MaCAN network and attempts to adjust local time to keep it in sync.
As can be seen in Figure~\ref[over-code] it calculates time in microseconds
and places the result into 64 bit unsigned integer which is large enough, but
the arithmetic itself is done with 32 bits of precision and leads to erroneous
results.

\midinsert \clabel[over-code]{Unsigned overflow causing bug}
\begtt
uint32_t time_ts;
uint64_t time_ts_us;
...
time_ts_us = time_ts * ctx->config->time_div;
\endtt
\caption/f Unsigned overflow causing bug. 
\endinsert

This bug was also found independently by Michal Sojka when he was presenting
MaCAN at an exhibition and Figure~\ref[over-fix] shows the fix already
implemented in mainline. Casting "time_ts"'s type to 64 bit unsigned integer
leads to the multiplication being performed with 64 bits of precision, which
means that overflow can still potentially happen, but only if the MaCAN network
in question is online for more than 500000 years.

\midinsert \clabel[over-fix]{The fix for unsigned overflow bug}
\begtt
uint32_t time_ts;
uint64_t time_ts_us;
...
time_ts_us = (uint64_t)time_ts * ctx->config->time_div;
\endtt
\caption/f The fix for unsigned overflow bug.
\endinsert

The other non-benign overflow is in the event-loop mechanism, in timer expiry
tracking. It is currently dormant because MaCAN system time, stored in 64 bit
unsigned integer "now", is platform specific and could theoretically overflow.
All current platform implementation start system time at 0, but if a future
platform started system time at different value, it could trigger the overflow in
Figure~\ref[dormant-bug] and the overflow could cause errors in the future,
unless fixed. The bug lies in the expression
"t->expire_us = now + t->repeat_us" whos right-hand side can overflow and the
timer then will remain expired until MaCAN system time ("now") overflows as well.

\midinsert \clabel[dormant-bug]{Dormant bug in the event loop}
\begtt
for (macan_ev_timer *t = loop->timers; t; t = t->next) {
    if (now >= t->expire_us) {
        t->cb(loop, t, MACAN_EV_TIMER);
        t->expire_us = now + t->repeat_us;
    }
}
\endtt
\caption/f Dormant bug in the event loop.
\endinsert

The rest of the potential overflows KLEE found were classified as benign. This
either meant that they only occurred within 64 bit arithmetic and thus could
happen only theoretically, or they were intended. Figure~\ref[benign-bugs]
contains the flagged expressions.

\midinsert \clabel[benign-bugs]{Overview of benign overflows}
\begtt
return (read_time() + (uint64_t)ctx->time.offs) / ctx->config->time_div;

t->offs = (time_ts_us - read_time());

t->offs = (time_ts_us - t->nonauth_loc);

loc_us = now + t->offs;

w->expire_us = read_time() + w->after_us;
\endtt
\caption/f Overview of benign overflows.
\endinsert

Table~\ref[klee-table] shows an overview of bugs found, where were they found
and their classification. I added a ``dormant'' classification to label
overflow that currently doesn't cause bugs, but under different hardware could.

\midinsert \clabel[klee-table]{Overview of found overflows}
\ctable{lrl}{
\hfil File & Line & Classification \crl \tskip4pt
    cryptlib.c & 165 & causing undefined behaviour \cr
    macan.c & 409 & benign \cr
    macan.c & 468 & causing bugs \cr
    macan.c & 473 & benign \cr
    macan.c & 475 & benign \cr
    macan.c & 864 & benign \cr
    macan\_ev.c & 68 & benign \cr
    macan\_ev.c & 94 & dormant \cr
}
\caption/t Overview of found overflows.
\endinsert

\sec Complexity, limitations, execution time

As trying to test eMotor has shown, modifying software so it can be tested can
be difficult if it has weakly abstracted input. This limits the kinds of
software that can be tested using KLEE, to those with well abstracted inputs,
which usually means software that was written to be cross-platform.

Another difficulty in using KLEE to test software is that the tested software
requires modifications by programmer, which means that the validity of results
depends on programmer. This has shown itself when I created a
test program for the MaCAN library. Due to an error I made while configuring
the library in my test program, I ended up with a false positive results and
had to determine it was configuration error via manual inspection.

Apart from relying on programmer to prepare the test program correctly, another
potential pitfall of using KLEE to test software is the time it needs
to test a program. The MaCAN test setup described in previously has been 
running on modestly fast CPU\fnote{2GHz AMD Opteron 6128}
for 5 days without finishing. This is caused by
KLEE's complexity being exponential in both memory (because the number of
possible path generally increases exponentially with encountered conditional
branches) and in CPU time (because it attempts to solve SAT problem at every
branching).

The memory complexity can be mitigated at the cost of further increasing
runtime, by running KLEE with search strategy set to either Depth First Search
(DFS) or Iteratively Deepening Depth First Search (IDDFS) (which is only
experimentally supported), but there is no way to reduce the CPU time
complexity. Even though KLEE does not have to finish testing a program
completely to find bugs, safety critical software demands complete verification
(or at least as complete as possible).

Figure~\ref[klee-stats] shows runtime statistics from KLEE for test using the
DFS search strategy. "Instrs" is number of executed LLVM IR instructions,
"Time" is total time spent running, "ICov" is percentage of total instructions
covered during testing, "BCov" is percentage of branches covered, "ICount" is
the total number of instructions in the bitcode file and "TSolver" is
percentage of time spent in the SAT solver.

\midinsert \clabel[klee-stats]{KLEE's runtime statistics}
\begtt
------------------------------------------------------------------------
|  Path   |  Instrs|  Time(s)|  ICov(%)|  BCov(%)|  ICount|  TSolver(%)|
------------------------------------------------------------------------
|klee-last|52135650|302651.30|    77.61|    60.76|    1697|       99.39|
------------------------------------------------------------------------
\endtt
\caption/f KLEE's runtime statistics.
\endinsert

\rfc{Insert ``If the task has not been killed, it is still runnin'' joke
somewhere.}

\sec KLEE fitness for purpose

Overall we found KLEE fit for purpose, but with reservation. It has helped to
find two previously unknown bugs in the MaCAN library and another one that has
been independently found and fixed after I forked MaCAN for testing.

It provides sound analysis of software, but because most safety-critical
programs are hardware dependent and their runtime is expected to never
terminate, the software given to KLEE has to be modified and these
modifications can potentially obscure existing bugs.
Assuming no bugs were obscured by testing-enabling modifications, the analysis
is sound (does not provide false negatives), which for safety-critical software
is very valuable property of testing.

The cost of KLEE's analysis is exponential time and space complexity and
specific requirements on the design of tested software. This also means that
for software that resembles eMotor, having weakly abstracted hardware layer,
the high time investment for testing said software with KLEE might not be worth
it, depending on how critical said software is.



\chap Conclusion

I have tried to test two pieces of real-time safety-critical software using the
symbolic execution tool KLEE. Because of KLEE's limitations and requirements, I
could only proceed with testing of the MaCAN library and had to abandon testing
eMotor.

The results from testing the MaCAN library are mixed. After running for more
than 5 days, KLEE has found a critical bug, found already fixed bug again
and helped to find a currently dormant bug in the MaCAN implementation of the
library. Symbolic execution, using KLEE, will also be added amongst tools used
to test the library going forward.

On the other hand, as I have shown, even after running for more than 5 days,
KLEE has only covered approx. 60\% of all branches and 77\% of all LLVM IR
instructions in the test program. Because the progress of KLEE's test coverage
is non-linear and can in general be expected to be logarithmic, I predict that
even after another 5 days KLEE would not have finished running the MaCAN test
program.

Thus we conclude that KLEE can be a valuable tool to use for verification of
real-time safety-critical software, but the software has to be designed from
the start with using KLEE in mind. This means liberal use of assertions,
minimizing complexity of branches, well abstracted inputs and documented parts
that are intractable for symbolic execution, such as cryptographic primitives.

In closing I think there is a niche for a symbolic execution tools targeted
specifically towards real-time safety-critical software systems, one that has
not been yet filled with an already existing symbolic execution tool. It could
provide a more comprehensive set of checks (i.e. no currently existing tool
checks against aliasing violations) and have specific annotations to help with
managing runtime complexity.



\nextoddpage

\bibchap
\usebib/c (simple) mybase
%\usebib/<sorttype> (<style>) <bibfile>
%sorttype c -- citation order in text
%sorttype s -- by key in style file


%Supposedly "Zadání práce" if in czech.
\app Specification

\picw=\hsize
\cinspic specification-en.pdf
\vskip-2cm
\vfil\break
\picw=\hsize
\cinspic specification-cz.pdf
\nextoddpage


\app Glossary\par
\makeglos

\nextoddpage

\app Contents of enclosed DVD

The DVD enclosed with this thesis contains digital copy of thesis itself in the
"thesis-pdf" folder, code and patches I made while working on my thesis in the
"thesis-sw" folder and all raw results from KLEE runs I used to make the final
report in the "thesis-data" folder.

\nextoddpage

\app Test result summary

Lorem Ipsum

\bye

